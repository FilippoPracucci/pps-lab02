--- 3a ---

val positive: Int => String = _ match
  case x if x >= 0 => "positive"
  case x if x < 0 => "negative"

def positive(x: Int): String = x match
  case x if x >= 0 => "positive"
  case _ => "negative"

println(positive(12)) // positive
println(positive(0)) // positive
println(positive(-3)) // negative

--- 3b ---

val empty: String => Boolean = _ == ""

val neg: (String => Boolean) => (String => Boolean) = p => s => !p(s)

def neg2(p: String => Boolean): String => Boolean = s => !p(s)

val notEmpty = neg(empty)

println(notEmpty("foo") && !notEmpty("")) // true

--- 3c ---

def neg3[X](p: X => Boolean): X => Boolean = x => !p(x)

val isZero: Int => Boolean = _ == 0

val isNotZero = neg3(isZero)

println(isNotZero(0)) // false
println(isZero(0)) // true
println(neg3(empty)("")) // false

--- 4 ---

val p1: (Int, Int) => Boolean => Boolean = (x, y) => z => x <= y == z

val p2: (Int, Int, Boolean) => Boolean = (x, y, z) => x <= y == z

def p3(x: Int, y: Int)(z: Boolean): Boolean = x <= y == z

def p4(x: Int, y: Int, z: Boolean): Boolean = x <= y == z

println(p1(2, 2)(true)) // true
println(p1(2, 2)(false)) // false
println(p2(2, 2, true)) // true
println(p2(2, 2, false)) // false
println(p3(2, 2)(true)) // true
println(p3(2, 2)(false)) // false
println(p4(2, 2, true)) // true
println(p4(2, 2, false)) // false

--- 5 ---

def compose(f: Int => Int, g: Int => Int): Int => Int = x => f(g(x))

println(compose(_ - 1, _ * 2)(5)) // 9

def compose2[X](f: X => X, g: X => X): X => X = x => f(g(x))

// In order to use the generic version there is the constraint to specify the type of the input.
println(compose2[Int](_ - 1, _ * 2)(5)) // 9
println(compose2[String](_ * 2, _ + ", ")("concat")) // concat, concat,
println(compose2[Boolean](_ == true, _ && true)(false)) // false


